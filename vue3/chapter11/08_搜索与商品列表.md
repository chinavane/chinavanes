# 08.搜索与商品列表

## 1)搜索的设置

对于搜索功能的实现首先需要考虑的是路由参数的类型，在 vue 中路由传参主要包含 params、query、hash 等参数内容，特别是 params 与 query 的参数类型应用的特别多。

对于 params 参数需要在静态路由表中对路由进行配置处理，可以利用:keyword?等方式进行声明，冒号是确认后面紧跟的是 params 参数，keyword 则是参数的名称，而问号则表示该 params 参数是可选项参数，即可传可不传。而 params 参数是无法与 path 路径进行结合使用的，所以需要考虑给路由设置 name，以确认 params 参数操作时需要实现的是命名路由跳转操作。

```js
{
			path: "/search/:keyword?",
			name: "Search",
			component: () => import("../views/search/index.vue"),
},
```

```js
const goSearch = () => {
  /*
		params参数如果直接携带，组件最终可以通过route.params来获取
		但是在地址栏中不会显示params参数
		要想地址栏中显示params参数，必须进行路由配置:keyword?才会显示
	*/
  router.push({
    name: 'Search',
    // 携带params参数，必须使用命名路由，不能用path
    params: {
      keyword: keyword.value, // ref数据获取值，必须.value
    },
    // 也要携带query参数
    query: route.query,
  });
};
```

## 2)三级分类点击也是搜索

不是只有搜索框实现的是搜索的功能，其实菜单里的三级分类的点击操作也是属于搜索功能，在点击以后同样需要实现指定条件商品内容的获取。

对于三级分类首先是划分分类级别，还需要确认分类的名称、id 等参数信息，这部分的内容可以利用 data-\*的方式进行自定义属性的设置。

```vue
<a :data-name="c1.categoryName" :data-id="c1.categoryId" :data-level="1">
{{ c1.categoryName }}
</a>
```

因为是点击操作，所以需要明确其事件类型。而且之前已经强调三级分类将实现的是事件委托功能，所以需要利用自定义数据方式进行对象内容的识别与参数传递操作，包括 name、id、level 等。为了拼接不同分类的不同 query 查询参数还可以利用动态赋值、取值的方式，即利用`[`category${level}Id`]: id`进行不同级别分类参数的组装处理。

```js
const goSearch = (e: MouseEvent) => {
  // 触发事件目标元素 e.target
  // 如何获取自定义属性（data-xxx）: e.target.dataset
  // 联合类型只能读取公共的属性和方法，
  // 想要读取某个类型的属性和方法，要使用类型断言
  // HTMLAnchorElement就是a标签的类型定义
  const { name, id, level } = (e.target as HTMLAnchorElement).dataset;

  // 解决：点击空白区域跳转问题
  // 因为点击空白区域不是a标签，就没有自定义属性
  if (!name) return;

  router.push({
    name: 'Search',
    query: {
      categoryName: name,
      [`category${level}Id`]: id,
    },
    params: route.params,
  });
};
```

## 3)商品列表数据筛选

### 1]商品列表功能总体描述

商品列表部分包含品牌、属性的筛选，综合、价格等内容的排序，商品列表的显示以及分页组件的调用等内容，最简单的处理应该是商品列表的循环渲染显示，只需要将查询到的数据进行 v-for 循环处理即可。而对于品牌与属性的筛选必须得先理清它们的概念以及与商品之间的关系。

首先是品牌，现在的商品都有一定的品牌属性，比如说苹果手机、小米手机、华为手机、三星手机等，那么同样是手机，苹果、小米、华为、三星就是不同手机的品牌属性，因为其品牌价值，不同品牌的手机其受众群体不一样，甚至价格也是不一样。而且不同的用户钟爱的品牌也是不同，可以选择不同的品牌更快速的获取到想要的商品内容。

其次是属性，因为商品也都有其特定的属性，比如说苹果手机，就算是相同外观的苹果手机，也可能会有不同内存大小的区别，比如说 32G 内存、64G 内存、128G 内存、256G 内存甚至 1T 内存等。那么这个内存的大小是否是苹果手机的一个属性特点呢？因为我们在查找苹果手机商品的时候可能需要选择不同内存大小属性的目标。商品的属性有很多，还有两个专业术语内容需要强化，一个是 SPU(Standard Product Unit)，即标准化产品单元，是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个 SPU。还有一个是 SKU(Stock Keeping Unit)，即库存进出计量的单位， 可以是以件、盒、托盘等为单位，SKU 是物理上不可分割的最小存货单元，在使用时要根据不同业态，不同管理模式来处理。以 iPhone XR 举个例子：iPhone XR 是 SPU，而 iPhone XR 黑色 128gG 则是 SKU，SPU 是一个商品，而 SKU 是该商品的不同的规格。

商品的排序在前端的应用并不复杂，主要难点是后台，因为牵扯综合、价格、销量、评价等不同维度的排序，会牵扯不同的算法处理，但前端需要考虑的只有升序与降序两个不同的情况而已。

分页操作显然不只在商品列表中进行使用，往后的订单等其它页面相信也存在分页的功能，那么就需要考虑到代码的封装，可以封装成组件模式。而分页的显示方式有多种多样，可以是分组分页、可以是下拉分页、可以是跳转分页、可以是序号分页，那么最终分页组件封装成什么模式则可以根据具体的业务需求来考虑。不同的业务需求对于分页展示的基础计算方式也会产生比较大的差异。

### 2]品牌与属性搜索

因为影响商品搜索结果的因素有很多，品牌、属性、排序、分页等，那么就必须先梳理清楚不同的条件的参数类型是什么，比如之前的关键字 params 参数、指定分类 query 参数等搜索条件以及现在所提及的品牌、属性、排序、分页响应式数据参数。最终可以在搜索商品列表函数中进行所有查询参数的组装，并实现商品查询参数的传递与结果返回操作。如果考虑用户不断点击操作频率的问题，还可以考虑使用防抖的性能优化处理。

```js
const searchGoodsList = debounce(async () => {
  // 搜索条件的组装
  const option = {
    ...searchOption, // 品牌、平台属性、排序、分页
    ...route.query, // 分类
    ...route.params, // 关键字
  };
  const data = await reqSearchGoodList(option);
}, 200);
```

对于品牌与属性参数的传递处理首先可以考虑的是将它们两进行组件的封装处理，这样的话就得明确查询参数所处的位置应该是父组件中，而品牌与属性所在的组件则是子组件。所以会存在子与父组件之间的通讯关系，因为需要将子组件的品牌、属性的内容点击结果传递到父组件中，父组件获取其传递值进行查询参数的拼装处理。那么子与父组件通讯采用的自定义事件通讯方式必须在子组件中先引入 defineEmits 并利用它进行事件的声明与使用操作，然后将品牌与属性的查询内容进行获取与传递处理。需要注意的是子组件中品牌与属性获取到的数据类型与数据结构，可能是字符串拼接模式，那么在父组件中商品查询时需要的参数类型与参数结构，需要将其改装成查询参数类型与结构模式。

```js
// 搜索品牌
const searchTrademark = (tm: string) => {
  // 判断上次的品牌条件 和 最新点击的品牌条件 是否相等
  if (searchOption.trademark === tm) {
    // 如果相等，说明点击同一个
    return;
  }
  // 更新搜索条件
  searchOption.trademark = tm;
  // 搜索
  searchGoodsList();
};
```

### 3]排序处理

因为排序的内容包括综合、销量、价格、评论等不同的类型，并且每种类型既可以进行升序与降序的处理，所以排序的工作内容主要是两个，一个是明确排序的名称，一个是排序的方式，而商品排序的参数目标是拼接字符串内容：

```js
// 默认情况下：是需要综合排序 1: 综合,2: 价格 asc: 升序,desc: 降序
order: '1:desc',
```

那么在进行排序链接点击时则需要考虑激活的动态样式，点击事件的监听以及升降序图标的显示等操作。

```vue
<li :class="{ active: order[0] === '2' }" @click="setOrder('2')">
  <a> 价格 <i v-show="order[0] === '2'" :class="['iconfont', order[1] === 'asc' ? 'icon-rising' : 'icon-falling', ]"></i></a>
</li>
```

至于商品排序功能的实现则需要考虑到数组内容的解构以确认排序名称以及排序类型，还需要考虑到原来的排序操作与新排序操作之间排序方式的改变，最终设置排序参数以实现商品列表的排序处理。

```js
const setOrder = (orderName: string) => {
  // orderName 1 或 2
  // orderType asc 或 desc
  let orderType;
  const [oldOrderName, oldOrderType] = order.value;
  /*
		点击相同的取反，点击不同的用默认值降序
	*/
  if (oldOrderName === orderName) {
    // 点击相同的取反
    orderType = oldOrderType === 'asc' ? 'desc' : 'asc';
  } else {
    // 点击不同的用默认值降序
    orderType = 'desc';
  }

  // 更新搜索条件
  searchOption.order = `${orderName}:${orderType}`;
  // 搜索
  searchGoodsList();
};
```

### 4]分页组件封装

项目中的分页组件主要想应用的是父子组件交互与通讯的练习，比如父组件传递属性到子组件，设置属性、传递属性、接收属性、使用属性的处理。并且主要考虑 defineProps 使用 vue 接收与校验模式以及使用 TypeScript 接收与校验模式比较。而分页组件一定会涉及到子与父组件之间的通讯，利用 defineEmits 定义分页码页面改变以及分页显示数量改变时的事件触发与事件监听操作。对于分页的显示主要是利用当前页码、每页显示数量以及总记录数进行属性计算模式的计算处理，如果分页功能要求更高，具有分页分组功能，那么其 computed 属性计算的公式变得更为的复杂而已，但不管怎么计算，分页的最终结果都是为了确保两个内容，一个是开始的记录位置，一个是结束的记录位置，这样才能确保当前页面的商品是从哪一条记录开始，最终显示哪条结束。

其实自己封装分页组件比较繁琐，并且可能考虑不到很多应用模式与场景，所以可以考虑利用很多 UI 框架中的分页组件即可，像 element-plus、antdv 等 UI 框架中都包含了 Pagination 分页组件，而这一组件也成了 UI 框架的基础必备组件之一。
