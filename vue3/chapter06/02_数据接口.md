# 02.数据接口

在进行 Vue 的数据请求实际操作之前我想还需要强化几个非常重要的概念，比如什么是接口，项目开发中接口的类型主要有哪些，接口定义的时候会采用什么样的定义约束，实际应用的接口模式有哪些，如何进行接口的测试等。

## 1)什么是接口

想搞清楚什么是接口需要先理解一个专业术语叫API，API全称是：Application Programming Interface，即：应用程序接口，是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。开发人员可以使用这些API接口进行编程开发，而又无需访问源码或理解内部工作机制的细节。而在上一节数据请求的概念中已经将网络层次划分成了客户端与服务器两端，也就是我们普遍认知中的前端与后端，它们之间应该存在一定的交互衔接，但前端是否需要详情了解后端的编码内容，同样的后端是否需要清楚前端的源码详情，答案一定是否定的，因为前后端之间更多的只是想实现数据之间的交互。所以前后端之间，甚至外部系统与系统之间以及内部系统各个子系统之间就产生了类似于API应用程序接口形式的数据接口的交互使用。所以数据接口就是将各个系统与层次之间的交互点通过一些特殊的规则也就是协议来进行数据之间的交互，这就是数据接口的应用需求。

## 2)接口的分类有哪些

前后端交互常见的数据接口分类主要包括webService接口以及Http接口。

Web Service也称为web服务，它是一种跨编程语言和操作系统平台的远程调用技术。Web Service采用标准的SOAP协议传输（SOAP：Simple Object Access Protocol简单对象访问协议，SOAP属于w3c标准，并且SOAP协议是基于http的应用层协议传输xml数据）。Web Service采用WSDL作为描述语言，也就是Web Service 的使用说明书，并且W3C为Web Service制定了一套传输数据类型，使用xml进行描述，即XSD（XML Schema Datatypes），任何语言写的web Service 接口在发送数据的时候都要转换成WebService标准的XSD发送。不过介于XML文件格式在数据交换时大小与性能的影响现在项目中使用SOAP数据接口的场景已经变得越来越少了。

Http接口需要先理清楚Http协议，Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的，所以Http连接是一种短连接，是一种无状态的连接。而Http协议的特点有很多，主要可概括如下部分：

1.支持客户、服务器模式；
2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、POST等，每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
3.灵活：Http允许传输任意类型的数据对象，而传输的类型由Content-Type加以标记。
4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
5.无状态：Http协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

而Http接口是走http协议，所以http协议拥有的特点在Http接口中都可以有所体现。但最重要的是Http接口是通过路径来区分调用的方法，请求报文都是key-value形式的，返回报文一般都是json串，相对于WebService中的SOAP协议返回较重的XML数据形式json就要轻要快很多，所以现在项目开发的时候绝大多数都已经应用了Http接口形式，并且请求方式使用的就是http协议中的get、post等方法。

## 3)SOAP 规范和REST风格

随着 Web API 的不断普及，对应不同的接口类型划分相应的协议规范也随之产生了，从而推动了信息交换的标准化，对应Web Service接口，采用简单对象访问协议 SOAP。使用 SOAP 设计的 API 会使用 XML 格式来收发消息，并通过 HTTP 或 SMTP 来接收请求。使用 SOAP 时，在不同环境中运行的应用或使用不同语言编写的应用能够更加轻松地共享信息。

对应Http接口应用，相关的规范有一个叫表述性状态传递（REST，Representational State Transfer）。遵循 REST 架构约束的 Web API 被称为 RESTful API。REST 与 SOAP 有着根本区别：SOAP 是一种协议，而 REST 是一种架构风格，这意味着 RESTful Web API 没有官方标准。它是由罗伊·菲尔丁（Roy Fielding）提出的，是用来描述创建 HTTP API 的标准方法的，他发现这四种常用的行为（查看（view），创建（create），编辑（edit）和删除（delete））都可以直接映射到 HTTP 中已实现的 GET、POST、PUT 和 DELETE 方法。REST 在操作时有一些基本的原则：

- 使用 HTTP 动词：GET、POST、PUT、DELETE 等，从名称转向动词，而动词的内容相对比较固定，这就让开发与应用人员有了一个统一的约束，从理解与应用都更为的明确；
- 统计设计标准：为每个资源设置 URI 清晰的定义 API 的路由指向以及明确定义请求与响应的数据格式，这样为后续沟通减少大量的时间成本；
- 无状态连接：服务器端不应保存过多上下文状态，即每个请求都是独立的，客户端及服务器端都不会保留连接的状态，也就是每次请求都是分离操作；
- 服务器可以设置缓存操作，而客户端接收到的也可以是缓存数据。客户端与服务器端是分离的，而客户端并不会关注数据的存储以及持久化等处理，服务器端也会进行其它 API 请求处理，而只有客户端请求时，服务器端才会执行代码返回结果；
- 通过 XML JSON 等数据格式进行数据传递，但事实上介于数据可读性、易操作性等因素，建议还是直接使用 JSON 数据进行数据传递。

## 4)接口模式

接口模式主要划分成了后端提供的项目正式接口与前端自行模拟构建的数据接口。

- ### 正式数据接口

当团队开发后端人员已经成功将接口内容进行了相应功能的处理，那么通常会给前端提供项目中将要应用的正式接口，而一般情况随着接口一同给予的还有相应的接口文档内容。不过现在很多的工具可以将接口与文档进行一同的整合，并且集成为一个统一的接口管理应用，比如说swagger就是其中一种接口文档生成工具。

现在尚硅谷电商项目的后端开发工程师就提供了一套“尚品汇”电商平台的swagger接口，其地址为：http://39.98.123.211:8510/swagger-ui.html

接口中除了可以进行webApi以及adminApi不同项目不同接口的切换还罗列了指定项目中提供的众多接口，比如webApi下的订单、购物车、交易、秒杀、用户、首页等。

![image-20221118085031634](http://qn.chinavanes.com/qiniu_picGo/image-20221118085031634.png)

当我们点击某个接口分类时将会罗列该接口分类下的各个具体详细的接口内容，并且清晰标明该接口的请求方式，像GET、POST、PUT、DELETE等，这也对应了RESTful API的开发风格，说明swagger接口可以遵循RESTful API接口的开发。

![image-20221118090356282](http://qn.chinavanes.com/qiniu_picGo/image-20221118090356282.png)

其实我们还可以点击具体某个接口查看该接口的详情，包括接口请求成功以后返回的数据模型结构，接口请求时可以传递的参数以及响应信息返回的编码解释等。

![image-20221118090755549](http://qn.chinavanes.com/qiniu_picGo/image-20221118090755549.png)

- ### 模拟数据接口

  假若当前公司或团队接收了一个全新的项目，这一项目对于产品、设计、前端、开发、测试、运维等技术团队的所有小组成员来说都是一个从零开始的项目，那么前端在进行 Vue 项目开发的时候后端程序也只能是刚起步阶段，所以他们可能没办法在第一时间给我们提供相应的正式测试接口，那么需要如何处理呢？我想你不可能和领导要求先休息一段时间，只有在后端接口准备好的情况下再回来继续项目的开发工作。前端项目与后台接口一定是同步开展进行的，所以就有了模拟数据的需求，让前端人员在暂时没有后台接口的情况下能够顺利的进行项目的继续开发操作。简单的说，我们需要在没有后台接口支持的情况下先假设模拟一些测试的接口数据。

  ![vue3-book-14.模拟数据需求的确认](http://qn.chinavanes.com/qiniu_picGo/vue3-book-14.%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E9%9C%80%E6%B1%82%E7%9A%84%E7%A1%AE%E8%AE%A4.png)

  不过，模拟数据的操作流程具体应该是如何呢？是否前端开发人员自已定义一个 json 数据就可以了？操作一个 json 文件应该可以实现数据的获取，但是对于接口的操作不光需要实现数据获取操作，还需要进行添加、修改、删除等其它的操作，也就是 rest api 的接口操作内容。除此之外，前端开发自己定义了一个数据结构，那么后台开发工程师是否知晓呢？如果后台开发工程师在进行接口开发完毕以后提供的数据结构名称与内容与之前前端开发工程师所定义的数据结构有所差异，那么代码内容是否需要进行修改，修改的工作量又是多少？我想这个结果是可以预见的，那将会是一个非常可怕的后果，相信所有的代码都会面临重新修改的严重后果。要么前端代码进行修改，要么后台接口代码进行修改，因为它们两者是不对应的。

  所以，模拟数据的结构应该由谁提供？如果后台提供了模拟数据的结构前端不需要又该如何？最好的方式是由前后端进行无障碍的协调沟通，当然前端开发如果有很好的主动性也可以先主动提出具体的接口数据结构需求，然后与后台开发工程师进行一同探讨，最终还是需要由后台开发工程师进行确认，将模拟数据的结构内容进行敲定。

  模拟数据操作的需求是很有必要的，而在这一过程中不同的岗位之间的沟通协调能力也被放置在了一个突出的位置，所以前端开发是否需要了解一些后台开发知识，后台开发是否需要清楚一些前端开发技术也成了现代开发技术人员的一些更高能力的要求。

  - 在线模拟数据

  模拟数据的使用根据不同的需求有不同的获取与创建方式，如果现在的项目只是起始阶段，只是为了确认项目中是否可以正常进行数据的增、删、改、查等功能性操作，对数据的结构内容并没有过多的要求，那么这时候完全不需要考虑自己费尽心思的去构建模拟数据内容，只需要利用网络上现有的一些在线模拟数据接口平台提供的模拟数据接口就可以实现这一目标。

  比如[JSONPlaceholder](https://jsonplaceholder.typicode.com/)就是一个应用率非常广泛的在线免费模拟数据接口平台，它的网站地址是：https://jsonplaceholder.typicode.com，平台每个月几十万的请求量得益于它的接口本身就已支持rest api 接口风格。

  JSONPlaceholder 在线模拟数据的局限是接口类型少，数据表现形式与项目不一定匹配相符，甚至请求到的数据内容都是英文示例，对于中文的支持力度几乎没有，而且很难修改其中数据结构的节点属性。那么针对这些弊端需要如何解决呢？我们可以尝试使用不同的工具配合来解决当前的困局。可以尝试利用 json-server 实现自定义模拟数据。

  - 本地模拟数据

  可以打开 github.com 搜索关键字 json-server 可以找到对应的模块内容，这是一款“在不到 30 秒的时间内即可获得零编码的完整模拟数据的工具，并且它还支持 rest api 接口风格”。

  想要使用此工具需要根据文档先全局安装 json-server 模块，在终端输入命令：

  ```bash
  npm install json-server -g
  ```

  然后新建立一个项目，目录名称设为 json-server-mock-server，并且在该目录下创建一文件 db.json，可以将文档中的 db.json 代码部分复制粘贴到刚刚新建的文件当中，并且在终端运行命令 json-server -p 5000 --watch db.json 即可，这一命令可以开启一个本地服务并且端口为设定的 5000。

  ```json
  {
    "posts": [{ "id": 1, "title": "json-server", "author": "typicode" }],
    "comments": [{ "id": 1, "body": "some comment", "postId": 1 }],
    "profile": { "name": "typicode" }
  }
  ```

  这时即可打开浏览器 http://localhost:5000 就可以看到本地服务的首页内容确认 json-server 已经成功开启，并且 resouce 中已经明确列出了已经支持的接口清单，包括 posts、comments 和 profile。posts 和 comments 的数据类型为数组，目前这两个接口下包含 1 个数组元素，而 profile 则是对象类型。那么就可以打开浏览器 http://localhost:5000/posts 查看到 posts 部分的数据列表，如果想要查看 id 为 1 的记录内容，则可以后面加上/1 的参数，具体地址为 http://localhost:5000/posts/1，就可以查看指定 id 的数据，这一操作过程有些像在线模拟数据 JSONPlaceholder 的操作流程，只不过数据结构与内容都可以由开发人员自行定制。

  ![image-20220501144038070](http://qn.chinavanes.com/qiniu_picGo/image-20220501144038070.png)

  不过目前仍旧有一个问题，就是在测试数据的时候，基本上所有的数据内容都需要手动进行增、删、改、查，就数据的输入而言，也会耗费蛮多的时间与精力。假若需要设置 1 万条数据，并且这些数据还要尽可能的接近真实项目的数据模式，那么是否需要安排人员一条一条数据的进行增设呢？我想这是绝不可能的。那么是否有更好的办法帮助我们实现一些更贴近实际的并且随意数量的数据内容呢？这就需要另一个工具，也就是假数据生成器 mock.js 的帮助。

  首先需要了解一下 mockjs 的应用场景，在程序开发并调试阶段往往开发人员对于数据的真实性并不很关注，例如姓名、地址、电话等信息经常会用 aaa/bbb/123 来进行输入、调示与展示操作，因而整体应用与最终的实际效果其实感觉上相差甚远。因为想要输入更多更实际的数据内容往往需要耗费很多的时间与精力，有些得不偿失。

  mock.js 则是一款可以随机生成数据并且可以拦截 Ajax 请求的工具，它的网站地址是http://mockjs.com。

  通过文档阅读可以了解到通过 mock.js 可以实现地址、日期、图片、网络、姓名、语句、段落、随机等上百种字段信息的内容的随机生成，并且还支持中英文不同的语言内容。

  我们可以在之前的 json-server-mock-server 目录中先进行 mock.js 模块的安装，需要在终端运行命令：

  ```bash
  npm install mockjs --save
  ```

  然后新建一个 index.js 程序文件，在该文件中引入 mockjs 模块，并尝试通过 mockjs 模块随机生成一句假数据

  json-server-mock-server/index.js

  ```js
  const Mock = require('mockjs');
  console.log(Mock.Random.cname());
  ```

  可以通过 node index.js 进行测试，发现每次运行该命令输出的信息都是不同的。由此可见，通过 mock.js 可以生成靠近实际应用的一些伪造的假数据。

  既然可以生成一条数据内容，那么生成多条数据应该如何处理呢？完全可以通过循环的方式进行处理。例如我们想构建一批用户数据，可以修改 index.js 程序文件：

  json-server-mock-server/index.js

  ```js
  const Mock = require('mockjs');
  for (let i = 0; i < 58; i++) {
    console.log(Mock.Random.cname());
  }
  ```

  <img src="http://qn.chinavanes.com/qiniu_picGo/image-20220501150520971.png" alt="image-20220501150520971" style="zoom:50%;" />

  现在的问题是虽然可以利用 mock.js 生成一系列的随机数据，但是似乎与 json-server 本地服务接口没有任何的关系，按照原来 json-server 的操作模式似乎应该把 mock.js 生成的数据复制粘贴到 db.json 文件当中去才行，这看起来并不智能。最好的方式就是让 mock.js 与 json-server 这两者建立起合作渠道确认结合。

  接下来可以修改 index.js 程序文件，在引入 Mock 以后利用 Mock.Random 进行随机内容的生成，不过在生成数据的时候可以利用 module.exports 进行模块的定义，并且定义的内容是一个函数。虽然 module.exports 是 nodejs 环境下 commonjs 的规范，说明当前程序的运行环境底层基础仍旧是 node。在这个函数中可以创建一个 data 数据类型为对象，并且包含一个 users 的属性节点。然后利用循环向这个 data 下的 users 数组内容进行数组元素对象值的追加，最终将 data 数据进行返回。这部分的内容看起来就是最为简单的函数定义与随机内容生成的处理，只不过多了一个模块暴露操作，而这个暴露的功能主要是让 json-server 能够去应用当前的模拟数据模块。

  json-server-mock-server/index.js

  ```js
  let Mock = require('mockjs');
  let Random = Mock.Random;
  
  module.exports = () => {
    let data = {
      users: [],
    };
  
    for (let i = 1; i <= 324; i++) {
      data.users.push({
        id: i,
        name: Random.cname(),
        address: Random.cword(10, 20),
        avatar: Random.image('100x100', Random.color(), '#FFF', Random.name()),
      });
    }
    return data;
  };
  ```

  现在就可以将之前运行 db.json 的终端命令进行终止，并利用 index.js 程序文件替换 db.json 数据文件，在终端运行命令：

  ```bash
  json-server -p 5000 --watch index.js
  ```

  现在打开 http://localhost:5000 就可以看到 users 进入到了我们的 json-server 服务接口当中，打开浏览器就可以查看与确认对应的接口内容。

